[
{
	"uri": "//localhost:1313/",
	"title": "AWS CodePipeline",
	"tags": [],
	"description": "",
	"content": "Work with Amazon Code PipeLine Overall In this workshop, we\u0026rsquo;ll delve into the fundamentals and hands-on exercises of Amazon CodePipeline, a powerful tool for automating your software release processes. You\u0026rsquo;ll gain practical experience by creating both public and private instance connections, enabling you to streamline your development workflow efficiently. Let\u0026rsquo;s dive in and explore the capabilities of CodePipeline together!\nContent Introduction Preparation Create Pipeline IAM Role Clean up resources "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.1-createecr/",
	"title": "Create an ECR",
	"tags": [],
	"description": "",
	"content": "Create an ECR Repository to store the docker image Go to Amazon Elastic Container Registry You can use the ECR console to create a ECR repository. If you already have a repository you want to use for this tutorial, you can skip this step.\naws ecr create-repository --repository-name my-demo-repo --image-tag-mutability IMMUTABLE --image-scanning-configuration scanOnPush=true "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "CICD pipeline overview\nEach stage of the CI/CD pipeline is structured as a logical unit in the delivery process. Each stage acts as a gate that vets a certain aspect of the code. As the code progresses through the pipeline, the assumption is that the quality of the code is higher in the later stages, because more aspects of it continue to be verified. Problems uncovered in an early stage stop the code from progressing through the pipeline. Results from the tests are immediately sent to the team, and all further builds and releases are stopped if software does not pass the stage.\nAWS brings in a complete set of CI/CD developer tools to accelerate software development and release cycles. AWS CodePipeline automates the build, test, and deploy phases of the release process every time there is a code change, based on the defined release model. This enables the rapid and reliable delivery of features and updates.\nCode pipelines can integrate with other services. These can be AWS Services, such as Amazon Simple Storage Service (Amazon S3), or third-party products, such as GitHub. AWS CodePipeline can address a variety of development and operation use cases including:\nCompiling, building, and testing code with AWS CodeBuild Continuous delivery of container-based applications to the cloud Pre-deployment validation of artifacts (such as descriptors and container images) required for network service or specific cloud-native network functions Over the long weekend, I have decided to build a simple CI/CD pipeline so that all the changes I am pushing to my test EKS cluster should be done via an automated way rather than me pushing all the changes manually.\nAWS Services used\nCodeCommit: Simple way of think of CodeCommit is the AWS equivalent of GitHub to host your private Git repositories. CodeBuild: CodeBuild is like your build server, which can compile your source code and produce artifacts. In this case, I use CodeBuild to create a docker image, push it to AWS Elastic Container Registry(ECR) and then deploy the image to the Kubernetes cluster. Generally, for deployment tasks, AWS has another service CodeDeploy, but currently, it doesn’t support EKS. Elastic Container Registry(ECR): AWS ECR is equivalent to dockerhub, where you can store your docker images. CodePipeline: CodePipeline is the AWS equivalent of Jenkins, where you build a pipeline including various stages. While testing I hit the dockerhub rate limit some time(as I am not logged in to dockerub), so I switched to AWS ECR public repository docker pull erc image\nSo my workflow is pretty simple, push the changes to CodeCommit, which will trigger the CodeBuild. CodeBuild will build the docker image and push it to ECR. From ECR, kubelet will pick the latest image and deploy it to the EKS cluster.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.2-createcodecommit/",
	"title": "Create a CodeCommit Repository",
	"tags": [],
	"description": "",
	"content": "Create a CodeCommit Repository Go to Amazon CodeCommit You can use the CodeCommit console to create a CodeCommit repository. If you already have a repository you want to use for this tutorial, you can skip this step. aws codecommit create-repository --repository-name mydemorepo "
},
{
	"uri": "//localhost:1313/2-prerequiste/",
	"title": "Preparation ",
	"tags": [],
	"description": "",
	"content": "Preparation Steps for Setting Up a CI/CD Pipeline on AWS Before setting up your CI/CD pipeline on AWS, it\u0026rsquo;s crucial to ensure that all necessary components are created and configured properly. Follow these steps to prepare your environment:\nCreate an Amazon ECR (Elastic Container Registry) Amazon ECR allows you to store, manage, and deploy Docker container images. Create a new ECR repository where your application images will be stored.\nCreate a CodeCommit Repository CodeCommit is a fully-managed source control service that hosts Git repositories. Create a CodeCommit repository to store your application code.\nCreate Git Credentials for IAM Service Generate Git credentials within AWS IAM (Identity and Access Management) to securely authenticate with your CodeCommit repository.\nClone the Git Repo Created in Step 2 Clone the newly created CodeCommit repository to your local development environment using Git commands. This will allow you to work with your application code locally.\nCopy All Files to the Application Directory Ensure that all necessary files, including your application code and Kubernetes manifests, are copied to the directory where you cloned the Git repository. This step ensures that your local environment is synced with the CodeCommit repository.\nCreate an STS Assume Role STS (Security Token Service) enables you to request temporary, limited-privilege credentials for accessing AWS resources. Create an STS Assume Role that CodeBuild will use to perform actions on your behalf.\nAdd the Newly Created IAM Role Grant the necessary permissions to the IAM role associated with CodeBuild. This ensures that CodeBuild has the required permissions to interact with AWS resources during the build process.\nCreate the buildspec.yml for CodeBuild The buildspec.yml file defines the build settings and commands that CodeBuild will execute during the build process. Create and configure the buildspec.yml file to specify the build steps for your application.\nBy completing these preparation steps, you\u0026rsquo;ll have all the necessary components in place to set up your CI/CD pipeline efficiently on AWS. With a well-prepared environment, you\u0026rsquo;ll be ready to automate the deployment of your applications seamlessly.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.3-createiam/",
	"title": "Create a git credential for IAM service",
	"tags": [],
	"description": "",
	"content": "Create a git credential for IAM service aws iam create-service-specific-credential --user-name 11thfeb --service-name codecommit.amazonaws.com Please make a note of these credentials. If you want to do it via UI, check the following doc https://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-gc.html\n"
},
{
	"uri": "//localhost:1313/3-createpipeline/",
	"title": "Create Pipeline",
	"tags": [],
	"description": "",
	"content": "Go to the CodePipeline url page and click on Create pipeline\nGive your pipeline name(my-eks-pipeline), and leave the service role field. It should be auto-populated. Leave the default setting in the rest of the field and click Next.\nUnder Source provider, choose AWS CodeCommit and choose the repository we created in Step 2. Leave the rest of the settings as default.\nUnder the build stage, choose AWS CodeBuild as the build provider, and under the Project name, click on Create project.\nClick on Create project.\nGive your project name and under a Managed image, select Amazon Linux 2\nChoose runtime as Standard, Image(from the drag down, choose the latest), and keep the rest of the settings as default.\nIf your buildspec.yml exists at the Git repository’s root, you don’t need to specify it here.\nSpecify the details if you want to send logs to CloudWatch or S3. Click on Continue to CodePipeline at the bottom of the screen.\nClick on Continue to CodePipeline.\nBefore moving to the next step, you need to add a few environment variables, as mentioned above.\nUnder the deploy stage, click on Skip deploy stage. As deploy doesn’t support EKS, we already specified the deployed step in the build stage.\nReview your pipeline configuration and click on Create pipeline.\nThe first run of the pipeline will fail as CodeBuild doesn’t have permission to update to the EKS cluster.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.4-clonerepo/",
	"title": "Clone the git repo created in step 2",
	"tags": [],
	"description": "",
	"content": "Once the credentials is created, clone the git repo created in step 2 git clone https://git-codecommit.ap-southeast-1.amazonaws.com/v1/repos/mydemorepo Cloning into \u0026#39;mydemorepo\u0026#39;... Username for \u0026#39;https://git-codecommit.ap-southeast-1.amazonaws.com\u0026#39;: 11thfeb-at-892515485494 Password for \u0026#39;https://11thfeb-at-892515485494@git-codecommit.ap-southeast-1.amazonaws.com\u0026#39;: warning: You appear to have cloned an empty repository NOTE: The username for code commit is different from the IAM username. Please pay special attention to that.\n"
},
{
	"uri": "//localhost:1313/4-iam/",
	"title": "Update IAM Role",
	"tags": [],
	"description": "",
	"content": "Update IAM Role Go to the IAM console, Policies, and click on Create policy.\nGo to IAM service management console In the policy, specify the below policy and the IAM role we created in Step 6.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::XXXXXXX:role/CodeBuildEKSRole\u0026#34; } ] } "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.5-copyfile/",
	"title": "Copy all the files to this application and Kubernetes manifests to this directory.",
	"tags": [],
	"description": "",
	"content": "Copy all the files to this application and Kubernetes manifests to this directory. \u0026gt; tree . ├── Dockerfile ├── app │ └── index.html └── manifests └── deployment.yaml Dockerfile\nFROM nginx COPY app /usr/share/nginx/html/app deployment.yaml\napiVersion: apps/v1 kind: Deployment metadata: name: my-eks-pipeline-deployment labels: app: my-eks-pipeline-deployment spec: replicas: 1 selector: matchLabels: app: my-eks-pipeline-deployment template: metadata: labels: app: my-eks-pipeline-deployment spec: containers: - name: my-eks-pipeline-deployment image: CONTAINER_IMAGE ports: - containerPort: 80 index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;h1\u0026gt;Welcome to Pipeline for EKS using CodeCommit, CodeBuild and CodePipeline \u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt; This is demo pipeline for EKS - v1\u0026lt;/h3\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "//localhost:1313/5-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Congratulations! You built a CI/CD pipeline using CodePipeline. Your pipeline began with code in CodeCommit.\nWhen you\u0026rsquo;re done exploring the resources you built for the lab, you can clean up by following these steps:\nDelete Pipeline Delete the pipeline from CodePipeline.\nInstructions Go to the AWS Management Console, select services then select AWS CodePipeline under Developer Tools Select my-eks-pipeline Select delete pipleline Delete CodeCommit repository Go to AWS CodeCommit Select mydemorepo Select delete repository Delete ECR Repository Go to Amazon Elastic Container Registry Select my-demo-repo Select delete ECR repository "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.6-createstsassume/",
	"title": "Create an STS assume role",
	"tags": [],
	"description": "",
	"content": "Create an STS assume role for CodeBuild to have permission to interact with AWS EKS. We will create an IAM role CodeBuildEKSRole and add an inline policy EKS:Describe that CodeBuild will use to interact with the EKS cluster via kubectl.\n1. Export your AWS Account(To get your aws account id run the following command aws sts get-caller-identity \u0026ndash;query Account \u0026ndash;output text)\nexport ACCOUNT_ID=\u0026lt;aws account id\u0026gt; 2. Set the Trust Policy\nTRUST=\u0026#34;{ \\\u0026#34;Version\\\u0026#34;: \\\u0026#34;2012-10-17\\\u0026#34;, \\\u0026#34;Statement\\\u0026#34;: [ { \\\u0026#34;Effect\\\u0026#34;: \\\u0026#34;Allow\\\u0026#34;, \\\u0026#34;Principal\\\u0026#34;: { \\\u0026#34;AWS\\\u0026#34;: \\\u0026#34;arn:aws:iam::${ACCOUNT_ID}:root\\\u0026#34; }, \\\u0026#34;Action\\\u0026#34;: \\\u0026#34;sts:AssumeRole\\\u0026#34; } ] }\u0026#34; 3. Create IAM Role for CodeBuild to Interact with EKS\naws iam create-role --role-name CodeBuildEKSRole --assume-role-policy-document \u0026#34;$TRUST\u0026#34; --output text --query \u0026#39;Role.Arn\u0026#39; 4. Create an Inline Policy with eks:Describe permission and redirect the output to eksdescribe.json\necho \u0026#39;{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;eks:Describe*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] }\u0026#39; \u0026gt; /tmp/eksdescribe.json 5. Add this Inline Policy to the IAM Role CodeBuildEKSRole\naws iam put-role-policy --role-name CodeBuildEKSRole --policy-name eks-describe-policy --policy-document file:///tmp/eksdescribe.json "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.7-createiamrole/",
	"title": "Add the newly created IAM role",
	"tags": [],
	"description": "",
	"content": "Next step is to add the newly created IAM role(CodeBuildEKSRole) to the aws-auth configmap of the EKS cluster. 1. Check the aws-auth configmap\nkubectl get configmap aws-auth -o yaml -n kube-system 2. Export your AWS Account(To get your aws account id run the following command aws sts get-caller-identity \u0026ndash;query Account \u0026ndash;output text)\nexport ACCOUNT_ID=\u0026lt;aws account id\u0026gt; 3. Set the ROLE value\nROLE=\u0026#34; - rolearn: arn:aws:iam::$ACCOUNT_ID:role/CodeBuildEKSRole\\n username: build\\n groups:\\n - system:masters\u0026#34; 4. Get the current aws-auth configMap data and add new role to it\nkubectl get -n kube-system configmap/aws-auth -o yaml | awk \u0026#34;/mapRoles: \\|/{print;print \\\u0026#34;$ROLE\\\u0026#34;;next}1\u0026#34; \u0026gt; /tmp/auth-patch.yml 5. Patch the aws-auth configmap with new role\nkubectl patch configmap/aws-auth -n kube-system --patch \u0026#34;$(cat /tmp/auth-patch.yml)\u0026#34; "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.8-codebuild/",
	"title": "Create the buildspec.yml for CodeBuild",
	"tags": [],
	"description": "",
	"content": "Next step is to create the buildspec.yml for CodeBuild. There are a lot of examples available on the internet. I refer to some of these and modify them based on my requirement https://github.com/aquasecurity/amazon-eks-devsecops/blob/master/buildspec.yml\nversion: 0.2 phases: install: commands: - echo \u0026#34;Install Phase - if you need additional package, add it in this stage\u0026#34; pre_build: commands: # This Docker Image tag will have date, time and Codecommit version - TAG=\u0026#34;$(date +%Y-%m-%d.%H.%M.%S).$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | head -c 8)\u0026#34; # Updating Docker Image tag in your Kubernetes Deployment Manifest - echo \u0026#34;Update Image tag in kubernetes manifest\u0026#34; - sed -i \u0026#39;s@CONTAINER_IMAGE@\u0026#39;\u0026#34;$REPOSITORY_URI:$TAG\u0026#34;\u0026#39;@\u0026#39; manifests/deployment.yaml # Check AWS CLI Version - echo \u0026#34;Checking AWS CLI Version...\u0026#34; - aws --version # Login to ECR Registry - echo \u0026#34;Login in to Amazon ECR Registry\u0026#34; - $(aws ecr get-login --no-include-email) # Update Kube config Home Directory - export KUBECONFIG=$HOME/.kube/config build: commands: # Building Docker Image - echo \u0026#34;Docker build started on `date`\u0026#34; - echo \u0026#34;Building the Docker image...\u0026#34; - docker build --tag $REPOSITORY_URL:$TAG . post_build: commands: # Push Docker Image to ECR Repository - echo \u0026#34;Docker build completed on `date`\u0026#34; - echo \u0026#34;Pushing the Docker image to ECR Repository\u0026#34; - docker push $REPOSITORY_URI:$TAG - echo \u0026#34;Docker Push to ECR Repository Completed - $REPOSITORY_URI:$TAG\u0026#34; # Get AWS Credential using STS Assume Role for kubectl - echo \u0026#34;Setting Environment Variables related to AWS CLI for Kube Config Setup\u0026#34; - CREDENTIALS=$(aws sts assume-role --role-arn $EKS_ROLE_ARN --role-session-name eks-codebuild --duration-seconds 900) - export AWS_ACCESS_KEY_ID=\u0026#34;$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.AccessKeyId\u0026#39;)\u0026#34; - export AWS_SECRET_ACCESS_KEY=\u0026#34;$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.SecretAccessKey\u0026#39;)\u0026#34; - export AWS_SESSION_TOKEN=\u0026#34;$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.SessionToken\u0026#39;)\u0026#34; - export AWS_EXPIRATION=$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.Expiration\u0026#39;) # Updating kubectl with your EKS Cluster - echo \u0026#34;Update Kube Config configuration\u0026#34; - aws eks update-kubeconfig --name $EKS_CLUSTERNAME # Show time, applying manifests changes using kubectl - echo \u0026#34;Apply changes to kube manifests\u0026#34; - kubectl apply -f manifests/ - echo \u0026#34;All done!!!! Kubernetes changes applied\u0026#34; # Create Artifacts which we can use if we want to continue our pipeline for other stages - printf \u0026#39;[{\u0026#34;name\u0026#34;:\u0026#34;deployment.yaml\u0026#34;,\u0026#34;imageUri\u0026#34;:\u0026#34;%s\u0026#34;}]\u0026#39; $REPOSITORY_URI:$TAG \u0026gt; build.json artifacts: files: - build.json - manifests/* In order for this buildspec to work you need to add some environment variable\nEKS_CLUSTERNAME=\u0026lt;your eks cluster name\u0026gt; EKS_ROLE_ARN=\u0026lt;IAM Role create in Step 6\u0026gt; REPOSITORY_URL=\u0026lt;ECR repository created in step 1\u0026gt; "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]