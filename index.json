[
{
	"uri": "//localhost:1313/",
	"title": "AWS CodePipeline",
	"tags": [],
	"description": "",
	"content": "Work with Amazon Code PipeLine Overall In this workshop, we\u0026rsquo;ll delve into the fundamentals and hands-on exercises of Amazon CodePipeline, a powerful tool for automating your software release processes. You\u0026rsquo;ll gain practical experience by creating both public and private instance connections, enabling you to streamline your development workflow efficiently. Let\u0026rsquo;s dive in and explore the capabilities of CodePipeline together!\nContent Introduction Preparation Create IAM Role \u0026amp; Policy Create Pipeline Clean up resources "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.1-createecr/",
	"title": "Create an ECR",
	"tags": [],
	"description": "",
	"content": "Create an ECR Repository to store the docker image Go to Amazon Elastic Container Registry You can use the ECR console to create a ECR repository. If you already have a repository you want to use for this tutorial, you can skip this step. aws ecr create-repository --repository-name my-demo-repo --image-tag-mutability IMMUTABLE --image-scanning-configuration scanOnPush=true Result of aws ecr create-repository Command\nUpon executing the aws ecr create-repository command with the specified parameters, you will receive a result indicating the status of the repository creation process. Here is what you can expect in the output: { \u0026#34;repository\u0026#34;: { \u0026#34;repositoryArn\u0026#34;: \u0026#34;arn:aws:ecr:ap-southeast-1:account-id:repository/my-demo-repo\u0026#34;, \u0026#34;registryId\u0026#34;: \u0026#34;account-id\u0026#34;, \u0026#34;repositoryName\u0026#34;: \u0026#34;my-demo-repo\u0026#34;, \u0026#34;repositoryUri\u0026#34;: \u0026#34;aws_account_id.dkr.ecr.ap-southeast-1.amazonaws.com/my-demo-repo\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2024-03-11T11:44:26.574000+07:00\u0026#34;, \u0026#34;imageTagMutability\u0026#34;: \u0026#34;IMMUTABLE\u0026#34;, \u0026#34;imageScanningConfiguration\u0026#34;: { \u0026#34;scanOnPush\u0026#34;: true }, \u0026#34;encryptionConfiguration\u0026#34;: { \u0026#34;encryptionType\u0026#34;: \u0026#34;AES256\u0026#34; } } } repositoryArn: The Amazon Resource Name (ARN) of the newly created repository. registryId: The AWS account ID that owns the repository. repositoryName: The name of the repository created, in this case, \u0026ldquo;my-demo-repo\u0026rdquo;. repositoryUri: The URI of the repository, which can be used to push and pull images. createdAt: The timestamp indicating when the repository was created. imageTagMutability: Specifies whether image tags can be overwritten or are immutable. In this case, it\u0026rsquo;s set to \u0026ldquo;IMMUTABLE\u0026rdquo;. imageScanningConfiguration: Indicates whether image scanning is enabled for this repository, with \u0026ldquo;scanOnPush\u0026rdquo; set to true. This output confirms that the repository \u0026ldquo;my-demo-repo\u0026rdquo; has been successfully created in Amazon ECR with the specified settings. You can now proceed to use this repository for storing and managing your Docker container images.\n"
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "CICD pipeline overview\nEach stage of the CI/CD pipeline is structured as a logical unit in the delivery process. Each stage acts as a gate that vets a certain aspect of the code. As the code progresses through the pipeline, the assumption is that the quality of the code is higher in the later stages, because more aspects of it continue to be verified. Problems uncovered in an early stage stop the code from progressing through the pipeline. Results from the tests are immediately sent to the team, and all further builds and releases are stopped if software does not pass the stage.\nAWS brings in a complete set of CI/CD developer tools to accelerate software development and release cycles. AWS CodePipeline automates the build, test, and deploy phases of the release process every time there is a code change, based on the defined release model. This enables the rapid and reliable delivery of features and updates.\nCode pipelines can integrate with other services. These can be AWS Services, such as Amazon Simple Storage Service (Amazon S3), or third-party products, such as GitHub. AWS CodePipeline can address a variety of development and operation use cases including:\nCompiling, building, and testing code with AWS CodeBuild Continuous delivery of container-based applications to the cloud Pre-deployment validation of artifacts (such as descriptors and container images) required for network service or specific cloud-native network functions Over the long weekend, I have decided to build a simple CI/CD pipeline so that all the changes I am pushing to my test EKS cluster should be done via an automated way rather than me pushing all the changes manually.\nAWS Services used\nCodeCommit: Simple way of think of CodeCommit is the AWS equivalent of GitHub to host your private Git repositories. CodeBuild: CodeBuild is like your build server, which can compile your source code and produce artifacts. In this case, I use CodeBuild to create a docker image, push it to AWS Elastic Container Registry(ECR) and then deploy the image to the Kubernetes cluster. Generally, for deployment tasks, AWS has another service CodeDeploy, but currently, it doesn’t support EKS. Elastic Container Registry(ECR): AWS ECR is equivalent to dockerhub, where you can store your docker images. CodePipeline: CodePipeline is the AWS equivalent of Jenkins, where you build a pipeline including various stages. While testing I hit the dockerhub rate limit some time(as I am not logged in to dockerub), so I switched to AWS ECR public repository docker pull erc image\nSo my workflow is pretty simple, push the changes to CodeCommit, which will trigger the CodeBuild. CodeBuild will build the docker image and push it to ECR. From ECR, kubelet will pick the latest image and deploy it to the EKS cluster.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.2-createcodecommit/",
	"title": "Create a CodeCommit Repository",
	"tags": [],
	"description": "",
	"content": "Create a CodeCommit Repository Go to Amazon CodeCommit You can use the CodeCommit console to create a CodeCommit repository. If you already have a repository you want to use for this tutorial, you can skip this step. aws codecommit create-repository --repository-name mydemorepo Result of aws codecommit create-repository Command\nUpon executing the aws codecommit create-repository command with the specified repository name, you will receive a result indicating the status of the repository creation process. Below is an example of what you can expect in the output: { \u0026#34;repositoryMetadata\u0026#34;: { \u0026#34;accountId\u0026#34;: \u0026#34;your-account-id\u0026#34;, \u0026#34;repositoryId\u0026#34;: \u0026#34;xxxxxxxx-xxxx-xxxx-xxxx-df99bbbee2d5\u0026#34;, \u0026#34;repositoryName\u0026#34;: \u0026#34;mydemorepo\u0026#34;, \u0026#34;repositoryDescription\u0026#34;: \u0026#34;mydemorepo\u0026#34;, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2024-03-11T11:46:07.525000+07:00\u0026#34;, \u0026#34;creationDate\u0026#34;: \u0026#34;2024-03-11T11:46:07.525000+07:00\u0026#34;, \u0026#34;cloneUrlHttp\u0026#34;: \u0026#34;https://git-codecommit.ap-southeast-1.amazonaws.com/v1/repos/mydemorepo\u0026#34;, \u0026#34;cloneUrlSsh\u0026#34;: \u0026#34;ssh://git-codecommit.ap-southeast-1.amazonaws.com/v1/repos/mydemorepo\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:codecommit:region:your-account-id:mydemorepo\u0026#34; } } accountId: The AWS account ID that owns the repository. repositoryId: A unique identifier for the repository. repositoryName: The name of the repository created, in this case, \u0026ldquo;mydemorepo\u0026rdquo;. repositoryDescription: Description of the repository (if provided during creation). lastModifiedDate: The timestamp indicating the last modification date of the repository. creationDate: The timestamp indicating when the repository was created. cloneUrlHttp: The HTTPS URL that you can use to clone the repository. cloneUrlSsh: The SSH URL that you can use to clone the repository. Arn: The Amazon Resource Name (ARN) of the newly created repository. This output confirms that the repository \u0026ldquo;mydemorepo\u0026rdquo; has been successfully created in AWS CodeCommit. You can now use the provided URLs to clone the repository and start managing your source code.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/",
	"title": "Preparation ",
	"tags": [],
	"description": "",
	"content": "Preparation Steps for Setting Up a CI/CD Pipeline on AWS Before setting up your CI/CD pipeline on AWS, it\u0026rsquo;s crucial to ensure that all necessary components are created and configured properly. Follow these steps to prepare your environment:\nCreate an Amazon ECR (Elastic Container Registry) Amazon ECR allows you to store, manage, and deploy Docker container images. Create a new ECR repository where your application images will be stored.\nCreate a CodeCommit Repository CodeCommit is a fully-managed source control service that hosts Git repositories. Create a CodeCommit repository to store your application code.\nCreate Git Credentials for IAM Service Generate Git credentials within AWS IAM (Identity and Access Management) to securely authenticate with your CodeCommit repository.\nClone the Git Repo Created in Step 2 Clone the newly created CodeCommit repository to your local development environment using Git commands. This will allow you to work with your application code locally.\nTransfer all necessary files to the Application directory Ensure that all necessary files, including your application code and Kubernetes manifests, are copied to the directory where you cloned the Git repository. This step ensures that your local environment is synced with the CodeCommit repository.\nCreate an STS Assume Role STS (Security Token Service) enables you to request temporary, limited-privilege credentials for accessing AWS resources. Create an STS Assume Role that CodeBuild will use to perform actions on your behalf.\nAdd the Newly Created IAM Role Grant the necessary permissions to the IAM role associated with CodeBuild. This ensures that CodeBuild has the required permissions to interact with AWS resources during the build process.\nCreate the buildspec.yml for CodeBuild The buildspec.yml file defines the build settings and commands that CodeBuild will execute during the build process. Create and configure the buildspec.yml file to specify the build steps for your application.\nBy completing these preparation steps, you\u0026rsquo;ll have all the necessary components in place to set up your CI/CD pipeline efficiently on AWS. With a well-prepared environment, you\u0026rsquo;ll be ready to automate the deployment of your applications seamlessly.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.3-createiam/",
	"title": "Create a git credential for IAM service",
	"tags": [],
	"description": "",
	"content": "Create a git credential for IAM service aws iam create-service-specific-credential --user-name 11thfeb --service-name codecommit.amazonaws.com Result of aws iam create-service-specific-credential Command\nUpon executing the aws iam create-service-specific-credential command with the specified parameters, you will receive a result indicating the status of the service-specific credential creation process. Below is an example of what you can expect in the output: { \u0026#34;ServiceSpecificCredential\u0026#34;: { \u0026#34;UserName\u0026#34;: \u0026#34;11thfeb\u0026#34;, \u0026#34;ServiceUserName\u0026#34;: \u0026#34;11thfeb-codecommit\u0026#34;, \u0026#34;ServicePassword\u0026#34;: \u0026#34;generated-service-password\u0026#34;, \u0026#34;ServiceSpecificCredentialId\u0026#34;: \u0026#34;generated-credential-id\u0026#34;, \u0026#34;CreateDate\u0026#34;: \u0026#34;2024-03-11T11:50:07.525000+07:00\u0026#34;, \u0026#34;ServiceName\u0026#34;: \u0026#34;codecommit.amazonaws.com\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Active\u0026#34;, \u0026#34;SecretAccessKey\u0026#34;: \u0026#34;generated-secret-access-key\u0026#34; } } UserName: The name of the IAM user associated with the service-specific credential. ServiceUserName: The name of the service-specific credential IAM user for CodeCommit. ServicePassword: The generated password for the service-specific credential. ServiceSpecificCredentialId: A unique identifier for the service-specific credential. CreateDate: The timestamp indicating when the service-specific credential was created. ServiceName: The name of the service associated with the credential, in this case, \u0026ldquo;codecommit.amazonaws.com\u0026rdquo;. Status: The status of the service-specific credential, which is typically \u0026ldquo;Active\u0026rdquo; upon creation. SecretAccessKey: The generated secret access key for the service-specific credential. This output confirms that the service-specific credential for accessing CodeCommit has been successfully created for the IAM user \u0026ldquo;11thfeb\u0026rdquo;. Make sure to securely store the generated password and secret access key, as they are required for authentication when accessing CodeCommit repositories.\nPlease make a note of these credentials. If you want to do it via UI, check the following doc https://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-gc.html\n"
},
{
	"uri": "//localhost:1313/3-iam/",
	"title": "Create IAM Role &amp; Policy",
	"tags": [],
	"description": "",
	"content": "Introduction In Amazon Web Services (AWS), Identity and Access Management (IAM) plays a crucial role in controlling access to various AWS services and resources. Creating IAM roles and policies allows you to define granular permissions for users, applications, or services within your AWS environment. This guide will walk you through the process of creating an IAM role and policy to grant specific access to AWS services.\nDefine Access Requirements:\nIdentify the specific AWS services and resources that require access. Determine the level of access required (e.g., read-only, write, administrative). Navigate to IAM Console:\nLog in to the AWS Management Console and navigate to the IAM service. Create IAM Role:\nClick on \u0026ldquo;Roles\u0026rdquo; in the left-hand navigation pane. Click on the \u0026ldquo;Create role\u0026rdquo; button. Select the service that will use the role (e.g., AWS service, another AWS account). Choose the use case or service role permissions policies that align with your access requirements. Optionally, add tags to the role for better organization and management. Review and confirm the role details before creating it. Create IAM Policy:\nClick on \u0026ldquo;Policies\u0026rdquo; in the left-hand navigation pane. Click on the \u0026ldquo;Create policy\u0026rdquo; button. Choose between the JSON and Visual Editor options to define the policy. Define the policy\u0026rsquo;s permissions, specifying actions, resources, and conditions. Review and validate the policy to ensure it aligns with your access requirements. Give the policy a descriptive name and optionally add a description. Review and confirm the policy details before creating it. Attach Policy to Role:\nGo back to the Roles section in the IAM console. Select the role you created earlier. Under the \u0026ldquo;Permissions\u0026rdquo; tab, click on \u0026ldquo;Attach policies.\u0026rdquo; Search for and select the policy you created in the previous step. Review the policy summary and attach it to the role. Test and Monitor:\nValidate the access permissions by testing the role with the intended AWS service or resource. Monitor the IAM role and policy for any changes or updates required based on evolving access requirements.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.4-clonerepo/",
	"title": "Clone the git repo created in step 2",
	"tags": [],
	"description": "",
	"content": "Once the credentials is created, clone the git repo created in step 2 git clone https://git-codecommit.ap-southeast-1.amazonaws.com/v1/repos/mydemorepo Cloning into \u0026#39;mydemorepo\u0026#39;... Username for \u0026#39;https://git-codecommit.ap-southeast-1.amazonaws.com\u0026#39;: 11thfeb-at-xxxxxxxxxxxx Password for \u0026#39;https://11thfeb-at-xxxxxxxxxxxx@git-codecommit.ap-southeast-1.amazonaws.com\u0026#39;: warning: You appear to have cloned an empty repository After entering the username and password for authentication, the git clone command will proceed to clone the empty repository named \u0026lsquo;mydemorepo\u0026rsquo; into the local directory. You can now start adding files, making commits, and pushing changes to the CodeCommit repository.\nNOTE: The username for code commit is different from the IAM username. Please pay special attention to that.\n"
},
{
	"uri": "//localhost:1313/4-createpipeline/4.1-createnewpipeline/",
	"title": "Create AWS CodePipeline",
	"tags": [],
	"description": "",
	"content": " Go to the CodePipeline url page and click on Create pipeline Give your pipeline name(my-eks-pipeline), and leave the service role field. It should be auto-populated. Leave the default setting in the rest of the field and click Next. "
},
{
	"uri": "//localhost:1313/4-createpipeline/",
	"title": "Create Pipeline",
	"tags": [],
	"description": "",
	"content": "Create AWS Pipeline Go to the CodePipeline URL and click on \u0026ldquo;Create pipeline\u0026rdquo;.\nProvide a name for your pipeline (e.g., \u0026ldquo;my-eks-pipeline\u0026rdquo;). The service role field should be auto-populated. Leave the default settings in the rest of the fields and click \u0026ldquo;Next\u0026rdquo;.\nUnder Source provider, choose \u0026ldquo;AWS CodeCommit\u0026rdquo; and select the repository created in Step 2. Leave the rest of the settings as default.\nUnder the build stage, choose \u0026ldquo;AWS CodeBuild\u0026rdquo; as the build provider. Click on \u0026ldquo;Create project\u0026rdquo;.\nGive your project a name and select \u0026ldquo;Amazon Linux 2\u0026rdquo; under Managed image. Choose \u0026ldquo;Standard\u0026rdquo; for runtime, and select the latest image. Keep the rest of the settings as default.\nIf your buildspec.yml exists at the root of the Git repository, you don’t need to specify it here.\nSpecify the details if you want to send logs to CloudWatch or S3. Click \u0026ldquo;Continue to CodePipeline\u0026rdquo; at the bottom of the screen.\nBefore moving to the next step, add the necessary environment variables as mentioned above.\nUnder the deploy stage, click on \u0026ldquo;Skip deploy stage\u0026rdquo;. As deployment to EKS is handled within the build stage, you don\u0026rsquo;t need a separate deploy stage.\n"
},
{
	"uri": "//localhost:1313/3-iam/3.1-policy/",
	"title": "Create Policy",
	"tags": [],
	"description": "",
	"content": "Add permission role for EKS. Go to the IAM console, Policies, and click on Create policy.\nGo to IAM service management console In the policy, specify the below policy and the IAM role we created in Step 6. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::XXXXXXX:role/CodeBuildEKSRole\u0026#34; } ] } Within this interface, you have the capability to input JSON data directly into the policy editor. Give your policy name (codebuild-sts-role), and click on the \u0026ldquo;Create policy\u0026rdquo; button to proceed to the next step. "
},
{
	"uri": "//localhost:1313/5-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Congratulations! You built a CI/CD pipeline using CodePipeline. Your pipeline began with code in CodeCommit.\nWhen you\u0026rsquo;re done exploring the resources you built for the lab, you can clean up by following these steps:\nDelete Pipeline Delete the pipeline from CodePipeline.\nGo to the AWS Management Console, select services then select AWS CodePipeline under Developer Tools Select my-eks-pipeline Select delete pipleline Delete CodeCommit repository Go to AWS CodeCommit Select mydemorepo Select delete repository Delete ECR Repository Go to Amazon Elastic Container Registry Select my-demo-repo Select delete ECR repository Delete Role Go to IAM Select Roles Select role you created for EKS. Example: \u0026ldquo;role-ap-southeast-1-my-eks-pipeline\u0026rdquo;. Click on the \u0026ldquo;delete\u0026rdquo; button to delete Delete Policy Go to IAM Select Policy. Search policy you created. Example: \u0026ldquo;code-sts-role\u0026rdquo;. Click on the \u0026ldquo;delete\u0026rdquo; button to delete. "
},
{
	"uri": "//localhost:1313/4-createpipeline/4.2-addsourcestage/",
	"title": "Add source stage",
	"tags": [],
	"description": "",
	"content": "Under Source provider, choose AWS CodeCommit and choose the repository we created in Step 2. Leave the rest of the settings as default.\nStart by selecting \u0026ldquo;AWS CodeCommit\u0026rdquo; as the source provider.\nWhen prompted for the repository name, provide a name for your repository, for example, \u0026ldquo;mydemorepo\u0026rdquo;. This repository name should match the name of the repository you\u0026rsquo;ve created in AWS CodeCommit.\nChoose the branch you want to use for your pipeline. For example, select the \u0026ldquo;master\u0026rdquo; branch if you want to use the main branch of your repository.\nLeave the default options for change detection and output artifact format unless you have specific requirements to customize them.\nOnce you\u0026rsquo;ve configured these settings, click on the \u0026ldquo;Next\u0026rdquo; button to proceed to the next step in setting up your pipeline.\n"
},
{
	"uri": "//localhost:1313/3-iam/3.2-role/",
	"title": "Create Role",
	"tags": [],
	"description": "",
	"content": "Add permission role for EKS. To access the IAM console and manage roles, follow these steps:\nNavigate to the IAM service management console. Select \u0026ldquo;Roles\u0026rdquo; from the menu and click on the desired role. Once selected, you\u0026rsquo;ll be presented with role information. Click on the \u0026ldquo;Attach policies\u0026rdquo; button to proceed. Search for the role created in the previous step, namely \u0026ldquo;codebuild-sts-role,\u0026rdquo; and click \u0026ldquo;Add permissions.\u0026rdquo; Next, search for \u0026ldquo;AmazonEC2ContainerRegistryFullAccess,\u0026rdquo; select it, and click \u0026ldquo;Add permissions.\u0026rdquo; Review your changes. The result will be displayed as shown below. "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.5-transferfile/",
	"title": "Transfer all necessary files",
	"tags": [],
	"description": "",
	"content": "Copy all the files to this application and Kubernetes manifests to this directory. \u0026gt; tree . ├── Dockerfile ├── app │ └── index.html └── manifests └── deployment.yaml Dockerfile This Dockerfile will create a Docker image based on the official Nginx image and copy the contents of the \u0026lsquo;app\u0026rsquo; directory from the current directory into the \u0026lsquo;/usr/share/nginx/html/app\u0026rsquo; directory within the container.\nFROM nginx COPY app /usr/share/nginx/html/app deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: my-eks-pipeline-deployment labels: app: my-eks-pipeline-deployment spec: replicas: 1 selector: matchLabels: app: my-eks-pipeline-deployment template: metadata: labels: app: my-eks-pipeline-deployment spec: containers: - name: my-eks-pipeline-deployment image: CONTAINER_IMAGE ports: - containerPort: 80 Replace CONTAINER_IMAGE with the actual image name and tag that you want to use for your deployment. This YAML defines a Kubernetes Deployment named my-eks-pipeline-deployment with one replica, using the specified container image and exposing port 80. Adjust the metadata, labels, and ports as needed for your specific use case.\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;h1\u0026gt;Welcome to Pipeline for EKS using CodeCommit, CodeBuild and CodePipeline \u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt; This is demo pipeline for EKS - v1\u0026lt;/h3\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; This HTML file displays a welcome message and version information for your pipeline demo. You can further customize the content, styling, and structure according to your preferences.\n"
},
{
	"uri": "//localhost:1313/4-createpipeline/4.3-addbuildstage/",
	"title": "Add build stage",
	"tags": [],
	"description": "",
	"content": "Under the build stage, choose AWS CodeBuild as the build provider, and under the Project name.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.6-createstsassume/",
	"title": "Create an STS assume role",
	"tags": [],
	"description": "",
	"content": "Create an STS assume role for CodeBuild to have permission to interact with AWS EKS. We will create an IAM role CodeBuildEKSRole and add an inline policy EKS:Describe that CodeBuild will use to interact with the EKS cluster via kubectl.\n1. Export your AWS Account(To get your aws account id run the following command aws sts get-caller-identity \u0026ndash;query Account \u0026ndash;output text)\nexport ACCOUNT_ID=\u0026lt;aws account id\u0026gt; 2. Set the Trust Policy\nTRUST=\u0026#34;{ \\\u0026#34;Version\\\u0026#34;: \\\u0026#34;2012-10-17\\\u0026#34;, \\\u0026#34;Statement\\\u0026#34;: [ { \\\u0026#34;Effect\\\u0026#34;: \\\u0026#34;Allow\\\u0026#34;, \\\u0026#34;Principal\\\u0026#34;: { \\\u0026#34;AWS\\\u0026#34;: \\\u0026#34;arn:aws:iam::${ACCOUNT_ID}:root\\\u0026#34; }, \\\u0026#34;Action\\\u0026#34;: \\\u0026#34;sts:AssumeRole\\\u0026#34; } ] }\u0026#34; 3. Create IAM Role for CodeBuild to Interact with EKS\naws iam create-role --role-name CodeBuildEKSRole --assume-role-policy-document \u0026#34;$TRUST\u0026#34; --output text --query \u0026#39;Role.Arn\u0026#39; 4. Create an Inline Policy with eks:Describe permission and redirect the output to eksdescribe.json\necho \u0026#39;{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;eks:Describe*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] }\u0026#39; \u0026gt; /tmp/eksdescribe.json 5. Add this Inline Policy to the IAM Role CodeBuildEKSRole\naws iam put-role-policy --role-name CodeBuildEKSRole --policy-name eks-describe-policy --policy-document file:///tmp/eksdescribe.json "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.7-createiamrole/",
	"title": "Add the newly created IAM role",
	"tags": [],
	"description": "",
	"content": "Next step is to add the newly created IAM role(CodeBuildEKSRole) to the aws-auth configmap of the EKS cluster. 1. Check the aws-auth configmap\nkubectl get configmap aws-auth -o yaml -n kube-system 2. Export your AWS Account(To get your aws account id run the following command aws sts get-caller-identity \u0026ndash;query Account \u0026ndash;output text)\nexport ACCOUNT_ID=\u0026lt;aws account id\u0026gt; 3. Set the ROLE value\nROLE=\u0026#34; - rolearn: arn:aws:iam::$ACCOUNT_ID:role/CodeBuildEKSRole\\n username: build\\n groups:\\n - system:masters\u0026#34; 4. Get the current aws-auth configMap data and add new role to it\nkubectl get -n kube-system configmap/aws-auth -o yaml | awk \u0026#34;/mapRoles: \\|/{print;print \\\u0026#34;$ROLE\\\u0026#34;;next}1\u0026#34; \u0026gt; /tmp/auth-patch.yml 5. Patch the aws-auth configmap with new role\nkubectl patch configmap/aws-auth -n kube-system --patch \u0026#34;$(cat /tmp/auth-patch.yml)\u0026#34; "
},
{
	"uri": "//localhost:1313/4-createpipeline/4.4-createproject/",
	"title": "Create project",
	"tags": [],
	"description": "",
	"content": " Click on Create project. Give your project name and under a Managed image, select Amazon Linux 2 Choose runtime as Standard, Image(from the drag down, choose the latest), and keep the rest of the settings as default. If your buildspec.yml exists at the Git repository’s root, you don’t need to specify it here. Specify the details if you want to send logs to CloudWatch or S3. Click on Continue to CodePipeline at the bottom of the screen. Click on Continue to CodePipeline. "
},
{
	"uri": "//localhost:1313/4-createpipeline/4.5-adddeploystage/",
	"title": "Add deploy stage",
	"tags": [],
	"description": "",
	"content": "\nBefore moving to the next step, you need to add a few environment variables, as mentioned above. Under the deploy stage, click on Skip deploy stage. As deploy doesn’t support EKS, I already specified the deployed step in the build stage. Click on the \u0026ldquo;Skip deploy stage\u0026rdquo; button to proceed to the next step Click on the \u0026ldquo;Skip\u0026rdquo; button to proceed to the next step "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.8-codebuild/",
	"title": "Create the buildspec.yml for CodeBuild",
	"tags": [],
	"description": "",
	"content": "Next step is to create the buildspec.yml for CodeBuild. version: 0.2 phases: install: commands: - echo \u0026#34;Install Phase - if you need additional package, add it in this stage\u0026#34; pre_build: commands: # This Docker Image tag will have date, time and Codecommit version - TAG=\u0026#34;$(date +%Y-%m-%d.%H.%M.%S).$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | head -c 8)\u0026#34; # Updating Docker Image tag in your Kubernetes Deployment Manifest - echo \u0026#34;Update Image tag in kubernetes manifest\u0026#34; - sed -i \u0026#39;s@CONTAINER_IMAGE@\u0026#39;\u0026#34;$REPOSITORY_URI:$TAG\u0026#34;\u0026#39;@\u0026#39; manifests/deployment.yaml # Check AWS CLI Version - echo \u0026#34;Checking AWS CLI Version...\u0026#34; - aws --version # Login to ECR Registry - echo \u0026#34;Login in to Amazon ECR Registry\u0026#34; - $(aws ecr get-login --no-include-email) # Update Kube config Home Directory - export KUBECONFIG=$HOME/.kube/config build: commands: # Building Docker Image - echo \u0026#34;Docker build started on `date`\u0026#34; - echo \u0026#34;Building the Docker image...\u0026#34; - docker build --tag $REPOSITORY_URL:$TAG . post_build: commands: # Push Docker Image to ECR Repository - echo \u0026#34;Docker build completed on `date`\u0026#34; - echo \u0026#34;Pushing the Docker image to ECR Repository\u0026#34; - docker push $REPOSITORY_URI:$TAG - echo \u0026#34;Docker Push to ECR Repository Completed - $REPOSITORY_URI:$TAG\u0026#34; # Get AWS Credential using STS Assume Role for kubectl - echo \u0026#34;Setting Environment Variables related to AWS CLI for Kube Config Setup\u0026#34; - CREDENTIALS=$(aws sts assume-role --role-arn $EKS_ROLE_ARN --role-session-name eks-codebuild --duration-seconds 900) - export AWS_ACCESS_KEY_ID=\u0026#34;$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.AccessKeyId\u0026#39;)\u0026#34; - export AWS_SECRET_ACCESS_KEY=\u0026#34;$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.SecretAccessKey\u0026#39;)\u0026#34; - export AWS_SESSION_TOKEN=\u0026#34;$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.SessionToken\u0026#39;)\u0026#34; - export AWS_EXPIRATION=$(echo ${CREDENTIALS} | jq -r \u0026#39;.Credentials.Expiration\u0026#39;) # Updating kubectl with your EKS Cluster - echo \u0026#34;Update Kube Config configuration\u0026#34; - aws eks update-kubeconfig --name $EKS_CLUSTERNAME # Show time, applying manifests changes using kubectl - echo \u0026#34;Apply changes to kube manifests\u0026#34; - kubectl apply -f manifests/ - echo \u0026#34;All done!!!! Kubernetes changes applied\u0026#34; # Create Artifacts which we can use if we want to continue our pipeline for other stages - printf \u0026#39;[{\u0026#34;name\u0026#34;:\u0026#34;deployment.yaml\u0026#34;,\u0026#34;imageUri\u0026#34;:\u0026#34;%s\u0026#34;}]\u0026#39; $REPOSITORY_URI:$TAG \u0026gt; build.json artifacts: files: - build.json - manifests/* Explanation:\nThe version field specifies the version of the buildspec file. The phases section defines the different phases of the build process. In the install phase, you can specify commands to install any necessary dependencies or packages. The pre_build phase executes commands before the build process starts. Here, it generates a unique tag for the Docker image, updates the Kubernetes manifest with the image tag, checks the AWS CLI - version, logs in to Amazon ECR, and sets up the Kubeconfig for Kubernetes access. The build phase builds the Docker image. The post_build phase executes commands after the build is complete. It pushes the Docker image to Amazon ECR, sets up AWS credentials for Kubernetes access, updates the Kubeconfig, applies changes to Kubernetes manifests, and generates build artifacts. The artifacts section specifies the files to be included as build artifacts. Here, it includes the build.json file and all files in the manifests directory. In order for this buildspec to work you need to add some environment variable\nEKS_CLUSTERNAME=\u0026lt;your eks cluster name\u0026gt; EKS_ROLE_ARN=\u0026lt;IAM Role create in Step 6\u0026gt; REPOSITORY_URL=\u0026lt;ECR repository created in step 1\u0026gt; "
},
{
	"uri": "//localhost:1313/4-createpipeline/4.6-review/",
	"title": "Review",
	"tags": [],
	"description": "",
	"content": " Take a moment to review the parameters and information you\u0026rsquo;ve configured in the previous steps. This ensures that your pipeline will be set up correctly according to your specifications.\nDouble-check the pipeline name, source provider, repository name, branch selection, and any other settings you\u0026rsquo;ve configured.\nVerify that the options for change detection and output artifact format are set to your desired defaults, or adjust them if necessary.\nPay close attention to any environment variables or additional configurations you\u0026rsquo;ve added, ensuring they are accurate and properly configured.\nIt\u0026rsquo;s always a good practice to review your configuration at least once before proceeding to create the pipeline. This helps prevent any potential errors or misconfigurations that could impact the functionality of your pipeline.\nOnce you\u0026rsquo;ve verified everything looks correct, you can confidently proceed by clicking the \u0026ldquo;Create pipeline\u0026rdquo; button to finalize the setup.\nClick on the \u0026ldquo;Create pipeline\u0026rdquo; button to proceed to the next step "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]